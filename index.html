<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Bansko Slalom ğŸ’˜</title>
  <style>
    :root{
      --bg1:#12051a; --bg2:#2b0b2a;
      --card:rgba(255,255,255,.08);
      --stroke:rgba(255,255,255,.14);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.72);
      --pink:#ff4d8d; --pink2:#ff79b0; --gold:#ffd6a6;
    }
    *{box-sizing:border-box}
    body{
      margin:0; color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 800px at 20% 10%, #3a0f3e 0%, transparent 55%),
                  radial-gradient(900px 600px at 90% 30%, #2a0e3f 0%, transparent 60%),
                  linear-gradient(160deg, var(--bg1), var(--bg2));
      min-height:100vh; overflow:hidden;
    }
    .wrap{max-width:960px;margin:0 auto;padding:14px}
    .topbar{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      position:fixed;left:0;right:0;top:0;z-index:10;
      padding:12px 14px;
      backdrop-filter: blur(10px);
    }
    .brand{display:flex;align-items:center;gap:10px}
    .logo{
      width:38px;height:38px;border-radius:14px;
      background: linear-gradient(135deg, var(--pink), #b14cff);
      box-shadow: 0 10px 30px rgba(255,77,141,.25);
      display:grid;place-items:center;font-size:20px;
    }
    .title{margin:0;font-size:14px;letter-spacing:.2px}
    .sub{margin-top:2px;font-size:12px;color:var(--muted)}
    .hud{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .pill{
      padding:8px 10px;border-radius:999px;
      background: var(--card); border:1px solid var(--stroke);
      color:var(--muted); font-size:12px;
      display:flex;gap:6px;align-items:center;
    }
    .pill b{color:var(--text)}
    .btn{
      border:0; cursor:pointer; user-select:none;
      padding:10px 12px;border-radius:14px;font-weight:800;
      background: linear-gradient(135deg, var(--pink), var(--pink2));
      color:white;
      box-shadow: 0 12px 30px rgba(255,77,141,.22);
    }
    .btn.secondary{
      background: rgba(255,255,255,.10);
      border:1px solid var(--stroke);
      box-shadow:none;
    }
    .btn:active{transform:translateY(1px)}
    .game{
      position:fixed; inset:0;
      padding-top:72px;
      display:grid; place-items:center;
    }
    canvas{
      width:min(920px, 96vw);
      height:min(620px, 78vh);
      border-radius:22px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 18px 40px rgba(0,0,0,.25);
      touch-action: none;
    }

    /* Mobile controls */
    .controls{
      position:fixed;left:0;right:0;bottom:10px;z-index:12;
      display:flex;justify-content:center;gap:12px;
      pointer-events:none;
    }
    .pad{
      pointer-events:auto;
      width:min(170px, 42vw);
      padding:14px 14px;border-radius:18px;
      background: rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.14);
      display:flex;align-items:center;justify-content:center;
      font-weight:900; letter-spacing:.5px;
      user-select:none;
    }
    .pad:active{transform:scale(.99)}
    .tip{
      position:fixed;left:14px;right:14px;bottom:74px;z-index:11;
      max-width:960px;margin:0 auto;
      color:var(--muted);font-size:12px;
      text-align:center;
      opacity:.95;
    }

    /* Modal */
    .modal{
      position:fixed;inset:0;display:none;place-items:center;
      background: rgba(0,0,0,.6); z-index:20; padding:16px;
    }
    .card{
      max-width:760px;width:100%;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.14);
      border-radius:22px;
      padding:16px;
      box-shadow: 0 18px 40px rgba(0,0,0,.3);
    }
    .card h2{margin:0;font-size:18px}
    .card p{margin:10px 0 0;color:var(--muted);line-height:1.6}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:14px}
    .tiny{font-size:12px;color:var(--muted);margin-top:10px}

    canvas#rain{position:fixed;inset:0;display:none;pointer-events:none;z-index:19}
  </style>
</head>
<body>
  <canvas id="rain"></canvas>

  <div class="topbar">
    <div class="brand">
      <div class="logo">â›·ï¸</div>
      <div>
        <p class="title">Bansko Slalom</p>
        <div class="sub">KapÄ±lardan geÃ§ â€¢ Engellerden kaÃ§ â€¢ Level atla â€¢ Finalde sÃ¼rpriz ğŸ’˜</div>
      </div>
    </div>
    <div class="hud">
      <div class="pill">Skor: <b id="score">0</b></div>
      <div class="pill">Level: <b id="level">1</b></div>
      <div class="pill">Can: <b id="lives">3</b></div>
      <button class="btn secondary" id="musicBtn">ğŸ”ˆ MÃ¼zik</button>
      <button class="btn" id="startBtn">BaÅŸlat</button>
    </div>
  </div>

  <div class="game">
    <canvas id="c" width="920" height="620"></canvas>
  </div>

  <div class="tip" id="tip">Telefon: alttaki â—€ â–¶ ile kay. Bilgisayar: â† â†’. KapÄ±lardan (kÄ±rmÄ±zÄ±/mavi) geÃ§, Ã§amlara Ã§arpma.</div>

  <div class="controls">
    <div class="pad" id="leftPad">â—€ SOL</div>
    <div class="pad" id="rightPad">SAÄ â–¶</div>
  </div>

  <div class="modal" id="modal">
    <div class="card">
      <h2 id="modalTitle">Bansko Slalom</h2>
      <p id="modalText"></p>
      <div class="row">
        <button class="btn" id="playAgain">Tekrar Oyna</button>
        <button class="btn secondary" id="closeModal">Kapat</button>
      </div>
      <div class="tiny">ÅarkÄ± iÃ§in repoya <b>song.mp3</b> yÃ¼klediysen, â€œMÃ¼zikâ€ butonuyla aÃ§Ä±lacak (telefon kuralÄ±).</div>
    </div>
  </div>

  <!-- optional music (put song.mp3 in repo root) -->
  <audio id="bgm" loop>
    <source src="song.mp3" type="audio/mpeg" />
  </audio>

<script>
(() => {
  // ====== Personalization ======
  const GIRL_NAME = "Ä°zgi";
  const FINAL_SCORE_TO_WIN = 120; // final aÃ§ma eÅŸiÄŸi (istersen dÃ¼ÅŸÃ¼rÃ¼rÃ¼z)

  const FINAL_TEXT =
`Ä°zgi ğŸ’˜

Banskoâ€™da birlikte kaydÄ±ÄŸÄ±mÄ±z o anâ€¦
benim iÃ§in hÃ¢lÃ¢ en gÃ¼zel â€œbaÅŸlangÄ±Ã§â€lardan.

Senin hayallerin de benim iÃ§in oyun deÄŸil â€” gerÃ§ek.
Romaâ€™da LUISS master hedefini birlikte kutlayacaÄŸÄ±z. ğŸ‡®ğŸ‡¹ğŸ“

Sevgililer gÃ¼nÃ¼n kutlu olsun.
Ä°yi ki varsÄ±n. ğŸ’—`;

  // ====== Canvas setup ======
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const levelEl = document.getElementById("level");
  const livesEl = document.getElementById("lives");
  const startBtn = document.getElementById("startBtn");
  const musicBtn = document.getElementById("musicBtn");
  const tip = document.getElementById("tip");

  const leftPad = document.getElementById("leftPad");
  const rightPad = document.getElementById("rightPad");

  const modal = document.getElementById("modal");
  const modalTitle = document.getElementById("modalTitle");
  const modalText = document.getElementById("modalText");
  const playAgain = document.getElementById("playAgain");
  const closeModal = document.getElementById("closeModal");

  const bgm = document.getElementById("bgm");

  // Heart rain
  const rainCanvas = document.getElementById("rain");
  const rctx = rainCanvas.getContext("2d");
  let rainOn = false, particles = [], rainRAF = null;

  function resizeRain(){
    rainCanvas.width = window.innerWidth * devicePixelRatio;
    rainCanvas.height = window.innerHeight * devicePixelRatio;
    rainCanvas.style.width = window.innerWidth + "px";
    rainCanvas.style.height = window.innerHeight + "px";
    rctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  function startHeartRain(count=280){
    resizeRain();
    rainCanvas.style.display = "block";
    rainOn = true;
    particles = [];
    const emojis = ["ğŸ’—","ğŸ’–","ğŸ’˜","ğŸ’•","ğŸ’"];
    for(let i=0;i<count;i++){
      particles.push({
        x: Math.random()*window.innerWidth,
        y: -Math.random()*window.innerHeight,
        vy: 2 + Math.random()*5.5,
        vx: -1 + Math.random()*2,
        s: 16 + Math.random()*18,
        r: Math.random()*Math.PI*2,
        w: emojis[Math.floor(Math.random()*emojis.length)]
      });
    }
    const loop = () => {
      if(!rainOn) return;
      rctx.clearRect(0,0,window.innerWidth,window.innerHeight);
      for(const p of particles){
        p.x += p.vx; p.y += p.vy; p.r += 0.02;
        if(p.y > window.innerHeight + 40){ p.y = -40; p.x = Math.random()*window.innerWidth; }
        rctx.save();
        rctx.translate(p.x, p.y);
        rctx.rotate(p.r);
        rctx.font = `${p.s}px system-ui`;
        rctx.fillText(p.w, 0, 0);
        rctx.restore();
      }
      rainRAF = requestAnimationFrame(loop);
    };
    loop();
  }
  function stopHeartRain(){
    rainOn = false;
    rainCanvas.style.display = "none";
    if(rainRAF) cancelAnimationFrame(rainRAF);
  }

  // ====== Game state ======
  const W = canvas.width, H = canvas.height;

  const player = {
    x: W/2, y: H*0.78,
    w: 32, h: 40,
    vx: 0,
    maxSpeed: 6.2,
  };

  let running = false;
  let score = 0;
  let level = 1;
  let lives = 3;

  let t = 0;
  let laneCenter = W/2;      // slalom path center
  let laneWidth = 250;       // gates span
  let speed = 3.2;           // world scroll speed
  let spawnCd = 0;

  let objects = []; // gates + trees + bonus
  let inputLeft = false;
  let inputRight = false;

  function resetGame(){
    running = false;
    score = 0;
    level = 1;
    lives = 3;
    t = 0;
    laneCenter = W/2;
    laneWidth = 250;
    speed = 3.2;
    spawnCd = 0;
    objects = [];
    player.x = W/2;
    player.vx = 0;
    syncHUD();
    tip.textContent = "BaÅŸlatâ€™a bas. KapÄ±lardan (kÄ±rmÄ±zÄ±/mavi) geÃ§, Ã§amlara Ã§arpma.";
  }

  function syncHUD(){
    scoreEl.textContent = Math.floor(score);
    levelEl.textContent = level;
    livesEl.textContent = lives;
  }

  function showModal(title, text){
    modalTitle.textContent = title;
    modalText.textContent = text;
    modal.style.display = "grid";
  }
  function hideModal(){
    modal.style.display = "none";
  }

  // ====== Spawning ======
  function spawnGateRow(){
    // slalom center wiggles
    laneCenter += Math.sin(t/40) * 14 + (Math.random()-0.5)*30;
    laneCenter = Math.max(160, Math.min(W-160, laneCenter));

    const gap = Math.max(110, laneWidth - level*12);
    const leftX = laneCenter - gap/2;
    const rightX = laneCenter + gap/2;

    // Gate posts
    objects.push({type:"gateL", x:leftX, y:-40, r:16, hit:false});
    objects.push({type:"gateR", x:rightX, y:-40, r:16, hit:false});

    // One random obstacle (tree) near edge
    if(Math.random() < 0.65){
      const side = Math.random() < 0.5 ? -1 : 1;
      const ox = laneCenter + side*(gap/2 + 70 + Math.random()*80);
      objects.push({type:"tree", x:ox, y:-40, r:18, hit:false});
    }

    // Sometimes a bonus heart in the middle
    if(Math.random() < 0.28){
      objects.push({type:"heart", x: laneCenter + (Math.random()-0.5)*90, y:-40, r:18, hit:false});
    }
  }

  // ====== Collisions ======
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  function collideCircle(px, py, pr, obj){
    return Math.hypot(px-obj.x, py-obj.y) < (pr + obj.r);
  }

  function damage(){
    lives--;
    syncHUD();
    // tiny screen flash
    flash = 1;
    if(lives <= 0){
      endGame(false);
    }
  }

  function endGame(won){
    running = false;
    if(won){
      startHeartRain(320);
      showModal("Final ğŸ’˜", FINAL_TEXT);
    } else {
      showModal("Oyun Bitti ğŸ˜„", `Skor: ${Math.floor(score)}\n\nTekrar dener misin? Bu sefer ${GIRL_NAME} iÃ§in kazan ğŸ’˜`);
    }
  }

  // ====== Rendering ======
  let flash = 0;

  function drawBackground(){
    // snow gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,"rgba(255,255,255,.08)");
    g.addColorStop(1,"rgba(0,0,0,.18)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // soft vignette
    ctx.fillStyle = "rgba(0,0,0,.12)";
    ctx.fillRect(0,0,W,H);
  }

  function drawSlopeLines(){
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(255,255,255,.22)";
    ctx.lineWidth = 2;
    for(let i=0;i<10;i++){
      const y = (i*80 + (t*speed)%80);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y+30);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawPlayer(){
    // skier body
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle = "rgba(255,255,255,.9)";
    ctx.beginPath();
    ctx.roundRect(-player.w/2, -player.h/2, player.w, player.h, 10);
    ctx.fill();

    // scarf
    ctx.fillStyle = "rgba(255,77,141,.85)";
    ctx.fillRect(-player.w/2, -player.h/2 + 10, player.w, 6);

    // skis
    ctx.strokeStyle = "rgba(255,214,166,.75)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-18, player.h/2 - 2);
    ctx.lineTo(-30, player.h/2 + 12);
    ctx.moveTo(18, player.h/2 - 2);
    ctx.lineTo(30, player.h/2 + 12);
    ctx.stroke();

    ctx.restore();
  }

  function drawObj(o){
    if(o.type === "gateL" || o.type === "gateR"){
      const isL = o.type === "gateL";
      ctx.save();
      ctx.translate(o.x, o.y);
      // pole
      ctx.strokeStyle = isL ? "rgba(255,90,90,.95)" : "rgba(90,170,255,.95)";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.moveTo(0,-18);
      ctx.lineTo(0,22);
      ctx.stroke();
      // flag
      ctx.fillStyle = isL ? "rgba(255,90,90,.75)" : "rgba(90,170,255,.75)";
      ctx.beginPath();
      ctx.moveTo(0,-10);
      ctx.lineTo(isL ? -26 : 26, -2);
      ctx.lineTo(0, 6);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      return;
    }
    if(o.type === "tree"){
      ctx.save();
      ctx.translate(o.x, o.y);
      ctx.fillStyle = "rgba(60, 200, 140, .75)";
      ctx.beginPath();
      ctx.moveTo(0,-24);
      ctx.lineTo(-18,14);
      ctx.lineTo(18,14);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,.35)";
      ctx.beginPath();
      ctx.arc(0,18,6,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
      return;
    }
    if(o.type === "heart"){
      ctx.save();
      ctx.translate(o.x, o.y);
      ctx.font = "28px system-ui";
      ctx.fillText("ğŸ’˜", -14, 10);
      ctx.restore();
      return;
    }
  }

  function drawFlash(){
    if(flash <= 0) return;
    ctx.save();
    ctx.globalAlpha = 0.18 * flash;
    ctx.fillStyle = "rgba(255,77,141,1)";
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  // ====== Update loop ======
  function update(){
    if(!running) return;

    // difficulty scaling
    level = 1 + Math.floor(score / 40);
    level = Math.min(level, 7);
    speed = 3.2 + level*0.55;
    laneWidth = 250 - level*10;
    player.maxSpeed = 6.2 + level*0.2;

    // input
    const accel = 0.55;
    if(inputLeft && !inputRight) player.vx -= accel;
    if(inputRight && !inputLeft) player.vx += accel;
    if(!inputLeft && !inputRight) player.vx *= 0.85;

    player.vx = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.vx));
    player.x += player.vx;

    // boundaries
    const margin = 48;
    if(player.x < margin){ player.x = margin; player.vx = 0; }
    if(player.x > W-margin){ player.x = W-margin; player.vx = 0; }

    // spawn rows
    spawnCd -= 1;
    if(spawnCd <= 0){
      spawnGateRow();
      spawnCd = Math.max(16, 34 - level*2); // more frequent with level
    }

    // move objects
    for(const o of objects) o.y += speed;

    // collisions
    const pr = 16;
    for(const o of objects){
      if(o.hit) continue;

      // score gates: pass between them (simple: when reaching player.y line)
      if((o.type === "gateL" || o.type === "gateR") && o.y > player.y && !o.hit){
        // only count once per pair by checking both posts close in y
        // mark hit to avoid repeats
        o.hit = true;
      }

      // hit trees
      if(o.type === "tree"){
        if(collideCircle(player.x, player.y, pr, o)){
          o.hit = true;
          damage();
        }
      }

      // collect heart
      if(o.type === "heart"){
        if(collideCircle(player.x, player.y, pr, o)){
          o.hit = true;
          score += 8; // bonus
        }
      }
    }

    // gate scoring: count each gate row when both posts pass player line and player was within gap
    // We'll detect by finding pairs that crossed line this frame:
    // Simple approach: score for each "gateL" that crosses below player and near a "gateR"
    // Keep a marker on gateL only.
    for(const o of objects){
      if(o.type !== "gateL" || o.scored) continue;
      if(o.y >= player.y){
        // find matching right post close in y
        const right = objects.find(r => r.type==="gateR" && !r.scored && Math.abs(r.y - o.y) < 6);
        if(right){
          o.scored = true; right.scored = true;
          const gapMin = Math.min(o.x, right.x);
          const gapMax = Math.max(o.x, right.x);
          if(player.x > gapMin && player.x < gapMax){
            score += 10;
          } else {
            // missed gate: small penalty + mild wobble
            score = Math.max(0, score - 3);
          }
        }
      }
    }

    // cleanup
    objects = objects.filter(o => o.y < H + 80);

    // score tick
    score += 0.08 * level;
    syncHUD();

    // win condition
    if(score >= FINAL_SCORE_TO_WIN){
      endGame(true);
    }

    // flash decay
    flash *= 0.9;
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    drawBackground();
    drawSlopeLines();

    // draw lane hint
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = "rgba(255,255,255,.25)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(laneCenter - laneWidth/2, 0);
    ctx.lineTo(laneCenter - laneWidth/2 + 30, H);
    ctx.moveTo(laneCenter + laneWidth/2, 0);
    ctx.lineTo(laneCenter + laneWidth/2 + 30, H);
    ctx.stroke();
    ctx.restore();

    // objects
    for(const o of objects) drawObj(o);

    drawPlayer();
    drawFlash();

    // overlay text when not running
    if(!running){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.25)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.textAlign = "center";
      ctx.font = "700 34px system-ui";
      ctx.fillText("Bansko Slalom", W/2, H/2 - 34);
      ctx.font = "600 16px system-ui";
      ctx.fillStyle = "rgba(255,255,255,.78)";
      ctx.fillText("BaÅŸlat'a bas â€¢ KapÄ±lardan geÃ§ â€¢ Ã‡amlara Ã§arpma", W/2, H/2 + 6);
      ctx.fillText("Telefon: alttaki â—€ â–¶ â€¢ PC: â† â†’", W/2, H/2 + 30);
      ctx.restore();
    }
  }

  function loop(){
    update();
    render();
    requestAnimationFrame(loop);
  }

  // ====== Input ======
  function setPad(el, on){
    el.style.background = on ? "rgba(255,255,255,.16)" : "rgba(255,255,255,.10)";
  }

  const down = (side) => (e) => { e.preventDefault(); e.stopPropagation();
    if(side==="L"){ inputLeft=true; setPad(leftPad,true); }
    if(side==="R"){ inputRight=true; setPad(rightPad,true); }
  };
  const up = (side) => (e) => { e.preventDefault(); e.stopPropagation();
    if(side==="L"){ inputLeft=false; setPad(leftPad,false); }
    if(side==="R"){ inputRight=false; setPad(rightPad,false); }
  };

  leftPad.addEventListener("pointerdown", down("L"), {passive:false});
  leftPad.addEventListener("pointerup", up("L"), {passive:false});
  leftPad.addEventListener("pointercancel", up("L"), {passive:false});
  leftPad.addEventListener("pointerleave", up("L"), {passive:false});

  rightPad.addEventListener("pointerdown", down("R"), {passive:false});
  rightPad.addEventListener("pointerup", up("R"), {passive:false});
  rightPad.addEventListener("pointercancel", up("R"), {passive:false});
  rightPad.addEventListener("pointerleave", up("R"), {passive:false});

  window.addEventListener("keydown", (e) => {
    if(e.key === "ArrowLeft") inputLeft = true;
    if(e.key === "ArrowRight") inputRight = true;
  });
  window.addEventListener("keyup", (e) => {
    if(e.key === "ArrowLeft") inputLeft = false;
    if(e.key === "ArrowRight") inputRight = false;
  });

  // ====== Buttons ======
  async function playMusic(){
    try{
      await bgm.play();
      musicBtn.textContent = "ğŸ”Š MÃ¼zik";
      return true;
    }catch{ return false; }
  }
  function stopMusic(){
    bgm.pause();
    musicBtn.textContent = "ğŸ”ˆ MÃ¼zik";
  }

  startBtn.addEventListener("click", async () => {
    stopHeartRain();
    hideModal();
    // user gesture -> allow audio
    await playMusic();
    if(!running){
      running = true;
      tip.textContent = "KapÄ±lardan geÃ§! ğŸ’™â¤ï¸  Kalp bonuslarÄ±nÄ± topla ğŸ’˜";
    }
  });

  musicBtn.addEventListener("click", async () => {
    if(bgm.paused){
      const ok = await playMusic();
      if(!ok) tip.textContent = "MÃ¼zik baÅŸlamadÄ±ysa: telefon sessiz modda olabilir. Yine de oyun Ã§alÄ±ÅŸÄ±r.";
    }else{
      stopMusic();
    }
  });

  playAgain.addEventListener("click", () => {
    stopHeartRain();
    hideModal();
    resetGame();
    running = true;
    tip.textContent = "Hadi bir daha! Bu sefer daha yÃ¼ksek skor ğŸ’˜";
  });

  closeModal.addEventListener("click", () => {
    stopHeartRain();
    hideModal();
  });

  window.addEventListener("resize", () => { if(rainOn) resizeRain(); });

  // Start
  resetGame();
  loop();

  // Polyfill for roundRect (older browsers)
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    };
  }
})();
</script>
</body>
</html>

